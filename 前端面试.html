<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />

		<title></title>
		<style type="text/css">
			html {
				font-size: calc(100vw/7.5);
			}
			
			body {
				font-size: 0.24rem;
			}
			
			div {
				margin: 0.2rem 0;
				line-height: 1.5em;
				background-color: ghostwhite;
				padding: 0.1rem;
			}
			
			div p {
				margin: 0;
				font-family: "微软雅黑";
				font-size: 0.22rem;
			}
		</style>
	</head>

	<body>
		<div class="text">
			<h3>#### 一些开放性题目</h3>
			<p>1.自我介绍：除了基本个人信息以外，面试官更想听的是你与众不同的地方和你的优势。</p>
			<p> 2.项目介绍(开发过程中遇到什么问题)</p>
			<p>3.如何看待前端开发？（前端变化越来越大，很多以前是后端人做的事情现在都需要前端来做）</p>
			<p>4.平时是如何学习前端开发的？（书籍、网络、朋友、老师）</p>
			<p>5.未来三到五年的规划是怎样的？（目标是做产品经理、项目经理）</p>
		</div>
		<div>
			<h3>块级元素与行内元素</h3>
			<p>1 块级元素：div  , p  , form,   ul,  li ,  ol, dl,    form,   address,  fieldset,  hr, menu,  table</p>
			<p>行内元素：span,   strong,   em,  br,  img ,  input,  label,  select,  textarea,  cite, </p>
			
			
		</div>
		<div>
			<h3>#### position的值， relative和absolute分别是相对于谁进行定位的？（重要*）</h3>
			<p> - `absolute` :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。 </p>
			<p>- `fixed` （老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。</p>
			<p>- `relative` 生成相对定位的元素，相对于其在普通流中的位置进行定位。</p>
			<p>- `static` 默认值。没有定位，元素出现在正常的流中</p>
		</div>
		
		  <div>
			<h3>#### 如何解决跨域问题（重要*）</h3>
			<p>>JSONP：</p>
			<p>原理是：动态插入`script`标签，通过`script`标签引入一个`js`文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的`json`数据作为参数传入。
由于同源策略的限制，`XmlHttpRequest`只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过`script`标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。</p>
			<p>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。</p>
		    </div>

		<div>
			<h3>#### HTML与XHTML——二者有什么区别</h3>
			<p> 区别：</p>
			<p> 1.所有的标记都必须要有一个相应的结束标记</p>
			<p>2.所有标签的元素和属性的名字都必须使用小写</p>
			<p> 3.所有的XML标记都必须合理嵌套</p>
			<p>4.所有的属性必须用引号""括起来</p>
			<p> 5.把所有
				<和&特殊符号用编码表示</p>
			<p> 6.给所有属性赋一个值</p>
			<p>7.不要在注释内容中使“--”</p>
		    <p>8.图片必须有说明文字</p>
		</div>
		
		
		<div>
			<h3>#### 什么样的前端代码是好的</h3>
			<p>高复用低耦合，这样文件小，好维护，而且好扩展。</p>
		</div>
		
		
		<div>
			<h3>#### `<strong>`，`<em>`和`<b>`，`<i>`标签</h3>
			<p>```html</p>
			<p><strong> 标签和 <em> 标签一样，用于强调文本，但它强调的程度更强一些。</p>
				<p>em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的 <i>...</i>;</p>
				<p>< b > < i >是视觉要素，分别表示无意义的加粗，无意义的斜体。</p>
				<p>em 和 strong 是表达要素(phrase elements)。</p>
				
		    </div>
		    
		    
			<div>
				<h3>#### 说说你对前端架构师的理解</h3>
				<p>负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率；</p>
				<p>带领团队完成研发工具及平台前端部分的设计、研发和维护；</p>
				<p>带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先</p>
				<p>负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训。</p>
		    </div>
		    
		    
		    	<div>
						<h3>#### ajax的缺点和在IE下的问题？</h3>
						<p>>ajax的缺点</p>
						<p>    1、ajax不支持浏览器back按钮。</p>
						<p>2、安全问题 AJAX暴露了与服务器交互的细节。</p>
						<p>3、对搜索引擎的支持比较弱。</p>
						<p>4、破坏了程序的异常机制。</p>
						<p>   5、不容易调试</p>
		    </div>
		    
		    
		    	<div>
			<h3>#### GET和POST的区别，何时使用POST？</h3>
			<p> GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符</p>
			<p>POST：一般用于修改服务器上的资源，对所发送的信息没有限制。</p>
			<p>     GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，

                                     也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。



                                        然而，在以下情况中，请使用 POST 请求：

                                       无法使用缓存文件（更新服务器上的文件或数据库）

					    向服务器发送大量数据（POST 没有数据量限制）
					
					    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p>
		   </div> 
		    
		       	<div>
			<h3>#### 创建ajax过程（重要******）</h3>
			<p>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.</p>
			<p>(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</p>
			<p>(3)设置响应HTTP请求状态变化的函数.</p>
			<p>(4)发送HTTP请求.</p>
			<p>(5)获取异步调用返回的数据.</p>
			<p>(6)使用JavaScript和DOM实现局部刷新.</p>
			
		    </div>
		    
		   <div>
			<h3>#### javascript对象的几种创建方式</h3>
			<p>1，工厂模式</p>
			<p>2，构造函数模式</p>
			<p>3，原型模式</p>
			<p> 4，混合构造函数和原型模式</p>
			<p>5，动态原型模式</p>
			<p>6，寄生构造函数模式</p>
			<p> 7，稳妥构造函数模式</p>
			
		    </div>
		    
		    	<div>
			<h3>#### javascript继承的6种方法</h3>
			<p>  1，原型链继承</p>
			<p>2，借用构造函数继承</p>
			<p>3，组合继承(原型+借用构造)</p>
			<p>4，原型式继承</p>
			<p>5，寄生式继承</p>
			<p>  6，寄生组合式继承</p>
			
		    </div>
		    
		    	<div>
			<h3>#### 对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</h3>
			<p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。</p>
			<p>   1、实现界面交互</p>
			<p>2、提升用户体验</p>
			<p>3、有了Node.js，前端可以实现服务端的一些事情</p>
			<p>前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，

			     参与项目，快速高质量完成实现效果图，精确到1px；
			
			     与团队成员，UI设计，产品经理的沟通；
			
			     做好的页面结构，页面重构和用户体验；
			
			     处理hack，兼容、写出优美的代码格式；
			
			     针对服务器的优化、拥抱最新前端技术。</p>
		    </div>
		    
		    	<div>
			<h3>#### DOM操作——怎样添加、移除、移动、复制、创建和查找节点。</h3>
			<p>>1）创建新节点</p>
			<p>  createDocumentFragment()    //创建一个DOM片段</p>
			<p> createElement()   //创建一个具体的元素</p>
			<p> createTextNode()   //创建一个文本节点</p>
			<p>>2）添加、移除、替换、插入</p>
			<p> appendChild()</p>
				<p>removeChild()</p>
			<p>replaceChild()</p>
			<p>insertBefore() //并没有insertAfter()</p>
			<p>>3）查找</p>
			<p>getElementsByTagName()    //通过标签名称</p>
			<p>     getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，
          会得到一个数组，其中包括id等于name值的)</p>
			<p>getElementById()    //通过元素Id，唯一性</p>
		    </div>
		    
		      <div>
		    	<h3>#### 解释下浮动和它的工作原理？清除浮动的技巧（重点）</h3>
		    	<p> 浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p>
		    	<p>  1.使用空标签清除浮动。</p>
		    	<p> 这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。</p>
		    	<p>2.使用overflow。</p>
		    	<p> 给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。</p>
		    	<p>3.使用after伪对象清除浮动。</p>
		    	<p>该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；</p>
		    </div>
		    
		    	<div>
			<h3>**清除浮动的几种方法：**</h3>
			<p>1，额外标签法，<div style="clear:both;"></div>（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）</p>
			<p> 2，使用after伪类</p>
			<p>3,浮动外部元素</p>
			<p>4,设置overflow为hidden或者auto</p>
		    </div>
		    
		    	<div>
			<h3>#### 浮动元素引起的问题和解决办法？</h3>
			<p> 浮动元素引起的问题：</p>
			<p>（1）父元素的高度无法被撑开，影响与父元素同级的元素</p>
			<p>（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后</p>
			<p>（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</p>
			<p>>解决方法：</p>
			<p>使用`CSS`中的`clear:both`;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加`clearfix`样式：</p>
			
		    </div>
		    
		    	<div>
			<h3>#### HTML与XHTML——二者有什么区别</h3>
			<p>   区别：</p>
			<p>   1.所有的标记都必须要有一个相应的结束标记</p>
			<p>2.所有标签的元素和属性的名字都必须使用小写</p>
			<p>3.所有的XML标记都必须合理嵌套</p>
			<p>   4.所有的属性必须用引号""括起来</p>
			<p> 5.把所有<和&特殊符号用编码表示</p>
			<p> 6.给所有属性赋一个值</p>
			<p> 7.不要在注释内容中使“--”</p>
			<p>8.图片必须有说明文字</p>
		    </div>
		    
		    	<div>
			<h3>>CSS3有哪些新特性？</h3>
			<p> CSS3实现圆角（border-radius），阴影（box-shadow），</p>
			<p> 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）</p>
			<p>  transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜</p>
			<p>    增加了更多的CSS选择器  多背景 rgba</p>
			<p>在CSS3中唯一引入的伪元素是::selection.</p>
			<p> 媒体查询，多栏布局</p>
			<p> border-image</p>
		    </div>
		    
		    	<div>
			<h3>#### `XML`和`JSON`的区别？（重要***）</h3>
			<p>(1).数据体积方面。JSON相对于XML来讲，数据的体积小，传递的速度更快些。</p>
			<p>(2).数据交互方面。JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。</p>
			<p>(3).数据描述方面。JSON对数据的描述性比XML较差。</p>
			<p>(4).传输速度方面。JSON的速度要远远快于XML。</p>
			<p>(5).使用最多的JSON</p>
		    </div>
		    
		    	<div>
			<h3>#### HTTP和HTTPS（文件传输协议）</h3>
			<p>`HTTP`协议通常承载于TCP协议之上，在`HTTP`和`TCP`之间添加一个安全协议层（`SSL`或`TSL`），这个时候，就成了我们常说的HTTPS。
默认HTTP的端口号为80，`HTTPS`的端口号为443。</p>
			<h3>#### 为什么`HTTPS`安全</h3>
			<p>因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用`HTTPS`，密钥在你和终点站才有。`https`之所以比`http`安全，是因为他利用`ssl/tls`协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性</p>
		    </div>
		    
		   <div>
			<h3>#### 你觉得前端工程的价值体现在哪（重要*****）</h3>
			<p>    为简化用户使用提供技术支持（交互部分）</p>
			<p>为多个浏览器兼容性提供支持</p>
			<p> 为提高用户浏览速度（浏览器性能）提供支持</p>
			<p>为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持</p>
			<p>为展示数据提供支持（数据接口）</p>
		    </div>
		    
		 <div>
		   <h3>#### 谈谈性能优化问题（重要*****）</h3>
			<p>代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。</p>
			<p>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等</p>
			<p>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。</p>
			<p>请求带宽：压缩文件，开启GZIP，</p>
			<h3>>代码层面的优化</h3>
			
			<p>用`hash-table`来优化查找</p>
			<p>- 少用全局变量</p>
			<p>- 用`innerHTML`代替`DOM`操作，减少`DOM`操作次数，优化`javascript`性能</p>
			<p> 用`setTimeout`来避免页面失去响应</p>
			<p>- 缓存DOM节点查找的结果</p>
			<p> 避免使用CSS Expression</p>
			<p>- 避免全局查询</p>
			<p>- 避免使用with(with会创建自己的作用域，会增加作用域链长度)</p>
				<p>- 避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率</p>
			<p>- 尽量避免写在HTML标签中写Style属性</p>
			<h3>#### 移动端性能优化</h3>
			
			<p>- 尽量使用css3动画，开启硬件加速。</p>
			<p>- 适当使用`touch`事件代替`click`事件。</p>
			<p>- 避免使用`css3`渐变阴影效果。</p>
			<p>- 可以用`transform: translateZ(0)`来开启硬件加速。</p>
				<p>- 不滥用Float。Float在渲染时计算量比较大，尽量减少使用</p>
			<p>- 不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。</p>
			<p> 合理使用requestAnimationFrame动画代替setTimeout</p>
			<p> CSS中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发GPU渲染，请合理使用。过渡使用会引发手机过耗电增加</p>
			<p> PC端的在移动端同样适用</p>
			<p> 媒体查询（PC+Mobile）</p>
				<p>rem 跟标签的字体单位（Mobile</p>
			
		    </div>
		    
		    	<div>
			<h3>#### 说说你对闭包的理解（重要！）</h3>
			<p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</p>
			<p>闭包有三个特性：</p>
			<p>>1.函数嵌套函数</p>
			<p>>2.函数内部可以引用外部的参数和变量</p>
			<p>>3.参数和变量不会被垃圾回收机制回收</p>
		    </div>
		    
		    	<div>
			<h3>#### cookie 和session 的区别（*）：</h3>
			<p>    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p>
			<p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</p>
			<p>  考虑到安全应当使用session。</p>
			<p> 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。</p>
			<p> 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>
			<p> 5、所以个人建议：

        将登陆信息等重要信息存放为SESSION
        其他信息如果需要保留，可以放在COOKIE中</p>
			
		    </div>
		    
		    <div>
		    	<h3>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？（重点****）</h3>

<p>```css </p>
   <p> 1.id选择器（ # myid）</p>

    <p>2.类选择器（.myclassname）</p>

   <p> 3.标签选择器（div, h1, p）</p>

   <p> 4.相邻选择器（h1 + p）</p>

   <p> 5.子选择器（ul > li）</p>

    <p>6.后代选择器（li a）</p>

   <p> 7.通配符选择器（ * ）</p>

   <p> 8.属性选择器（a[rel = "external"]）</p>

  <p>  9.伪类选择器（a: hover, li:nth-child）</p>
```


<h3>**优先级为:**</h3>


<p>`!important >  id > class > tag `</p>

<p>`important` 比 内联优先级高,但内联比 `id` 要高</p>



<h3>>CSS3新增伪类举例：</h3>

<p>```css</p>
   <p> p:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。</p>

   <p> p:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。</p>

   <p> p:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。</p>

   <p> p:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素。</p>

  <p>  p:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。</p>

  <p>  :enabled  :disabled 控制表单控件的禁用状态。</p>

   <p> :checked        单选框或复选框被选中。</p>
```

<h3>>CSS3有哪些新特性？</h3>

	<p>CSS3实现圆角（border-radius），
	阴影（box-shadow），
 	对文字加特效（text-shadow、），
 	线性渐变（gradient），
 	形变（transform）</p>
    <p>transform:</p>
    	<p>rotate(9deg)</p> 
    	<p>scale(0.85,0.90) </p>
    	<p>translate(0px,-30px) </p>
    	<p>skew(-9deg,0deg);//旋转,缩放,定位,倾斜</p>
 	<p>增加了更多的CSS选择器 </p>
 	<p> 多背景 rgba</p>
 	<p>在CSS3中唯一引入的伪元素是::selection.</p>
	<p> 媒体查询，多栏布局</p>
	<p>边框图片border-image</p>
	<p>CSS3中新增了一种盒模型计算方式：</p>
		    </div>
		    
		    	<div>
				<h3>#### 说说你对语义化的理解？（重点）（article selection aside  footer header 等等）</h3>
			<p>1，去掉或者丢失样式的时候能够让页面呈现出清晰的结构</p>
			<p>2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</p>
			<p>    3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</p>
			<p>4，便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p>
		    </div>
		    
		    
		    <div>
		    	<h3>>上下margin重合问题 （重点）</h3>
		    	<p>ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。

    解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</p>
		    	
		    </div>
		    
		    
		    <div>
		    	<h3>#### 请解释什么是事件代理 （重点）</h3>
		    	<p>事件代理（Event Delegation），又称之为事件委托。是 `JavaScript` 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是`DOM`元素的事件冒泡。使用事件代理的好处是可以提高性能。</p>
		    </div>
		      <div>
		    	<h3>#### ajax的缺点和在IE下的问题？（重点）</h3>
		    	<p>>ajax的缺点</p>
		    	<p>1、ajax不支持浏览器back按钮。</p>
		    	<p> 2、安全问题 AJAX暴露了与服务器交互的细节。</p>
		    	<p>3、对搜索引擎的支持比较弱</p>
		    	<p>   4、破坏了程序的异常机制。</p>
		    	 <p> 5、不容易调试。</p>
		    </div>
		      <div>
		    	<h3>#### 事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？（重点）</h3>
		    	<p> 1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。</p>
		    	<p> 2. 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。；</p>
		    	<p>3. `ev.stopPropagation()`;注意旧ie的方法 `ev.cancelBubble = true`;
</p>
		    	<p></p>
		    	<p></p>
		    	
		    </div>
	</body>
</html>